<?php

use PHPUnit\Framework\TestCase;
define('PHPUNIT_RUNNING', true);
require_once __DIR__ . '/../../Secure/B2/session.php';
require_once __DIR__ . '/../../Model/B2/demande.php';

class RecurrenceTest  extends TestCase{

    private PDO $pdo;
    private RecurrenceModel $modele;

    protected function setUp(): void {
        // ðŸ”¸ Connexion Ã  la base de test MySQL
        $this->pdo = Database::getInstance()->getConnection();
        $this->pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        $this->modele = new RecurrenceModel($this->pdo);

        // ðŸ”¸ Nettoyer les tables utilisÃ©es pour le test
        $this->pdo->exec("DELETE FROM recurrence");
        
    }

    // Teste si la session dÃ©marre correctement
    public function testSessionStart()
    {
        // Assure-toi que la session est dÃ©marrÃ©e
        if (session_status() == PHP_SESSION_NONE) {
            session_start();
        }

        // VÃ©rifie que la session existe
        $this->assertTrue(session_status() == PHP_SESSION_ACTIVE, "La session n'est pas active.");
    }

    // Teste si le token CSRF est bien gÃ©nÃ©rÃ©
    public function testGenerateCsrfToken()
    {
        // DÃ©marre une session
        if (session_status() == PHP_SESSION_NONE) {
            session_start();
        }
  
        // GÃ©nÃ¨re un token CSRF
        $token = generateCsrfToken();
  
        // VÃ©rifie que le token est bien gÃ©nÃ©rÃ©
        $this->assertNotEmpty($token, "Le token CSRF devrait Ãªtre gÃ©nÃ©rÃ©.");
        $this->assertTrue(strlen($token) > 0, "Le token CSRF ne devrait pas Ãªtre vide.");
    }

    // Teste si le token CSRF est valide
    public function testValidateCsrfToken()
    {
        // DÃ©marre une session
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }

        // GÃ©nÃ¨re un token CSRF
        $validToken = generateCsrfToken();

        // Ajoute un token CSRF incorrect pour tester
        $invalidToken = 'invalid-token';

        // Teste un token valide
        $this->assertTrue(validateCsrfToken($validToken), "Le token valide ne devrait pas Ã©chouer.");
        
        // Teste un token invalide
        $this->assertFalse(validateCsrfToken($invalidToken), "Le token invalide ne devrait pas Ãªtre validÃ©.");
    }

    // Teste si la session est protÃ©gÃ©e par le user-agent
    public function testUserAgentSessionProtection()
    {
        // DÃ©marre une session
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
 
        // DÃ©finit un agent utilisateur fictif pour ce test
        $_SERVER['HTTP_USER_AGENT'] = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36';
 
        // Initialise $_SESSION['user_agent']
        $_SESSION['user_agent'] = $_SERVER['HTTP_USER_AGENT'];
 
        // VÃ©rifie que la session a bien l'agent utilisateur
        $this->assertEquals($_SESSION['user_agent'], $_SERVER['HTTP_USER_AGENT'], "L'agent utilisateur dans la session ne correspond pas.");
    }

    public function testAjouterRecurrence(): void {
        $timestamp = mktime(0,0,0,04,10,2025);
        $result = $this->modele->ajouterRecurrence(
            "Test Sujet", "Description de test", date("Y/m/d",$timestamp),8,null,2,"mois",null
        );

        $this->assertTrue($result['success']);
        $this->assertEquals("RÃ©currence ajoutÃ©e avec succÃ¨s !", $result['message']);

        // VÃ©rifie que les donnÃ©es sont bien insÃ©rÃ©es
        $stmt = $this->pdo->query("SELECT * FROM recurrence WHERE sujet_reccurrence = 'Test Sujet'");
        $data = $stmt->fetch(PDO::FETCH_ASSOC);

        $this->assertNotEmpty($data);
        $this->assertEquals("Description de test", $data['desc_recurrence']);
    }

    public function testAjouterRecurrenceEtRecuperer(): void {
        $timestamp = mktime(0,0,0,04,10,2025);
        $result = $this->modele->ajouterRecurrence(
            "Test Sujet 2", "Description de test puis repris", date("Y/m/d",$timestamp),8,null,2,"mois",null
        );

        $this->assertTrue($result['success']);
        $this->assertEquals("RÃ©currence ajoutÃ©e avec succÃ¨s !", $result['message']);

        // VÃ©rifie que les donnÃ©es sont bien insÃ©rÃ©es
        $stmt = $this->pdo->query("SELECT id_recurrence , desc_recurrence FROM recurrence WHERE sujet_reccurrence = 'Test Sujet 2'");
        $data = $stmt->fetch(PDO::FETCH_ASSOC);
        $result = $this->modele->getById($data['id_recurrence']);

        $this->assertNotEmpty($data);
        $this->assertEquals("Description de test puis repris", $data['desc_recurrence']);
    }

    public function testAjouterRecurrenceFreqNull(): void {
        $timestamp = mktime(0,0,0,04,10,2025);
        $result = $this->modele->ajouterRecurrence(
            "Test Sujet Freq Invalide", "Description de test", date("Y/m/d",$timestamp),null,null,2,"mois",null
        );

        $this->assertFalse($result['success']);
        $this->assertEquals("Entrez un nombre pour la frÃ©quence", $result['message']);
        
    }

    public function testAjouterRecurrenceFreqNegative(): void {
        $timestamp = mktime(0,0,0,04,10,2025);
        $result = $this->modele->ajouterRecurrence(
            "Test Sujet Freq Invalide", "Description de test", date("Y/m/d",$timestamp),-5,null,2,"mois",null
        );

        $this->assertFalse($result['success']);
        $this->assertEquals("La frÃ©quence doit Ãªtre un nombre positif", $result['message']);
    }

    public function testAjouterRecurrenceFreqSupÃ©rieurA100Mois(): void {
        $timestamp = mktime(0,0,0,04,10,2025);
        $result = $this->modele->ajouterRecurrence(
            "Test Sujet Freq Invalide", "Description de test", date("Y/m/d",$timestamp),150,null,2,"mois",null
        );

        $this->assertFalse($result['success']);
        $this->assertEquals("Entrez une frÃ©quence valide pour les mois, pas plus de 100 mois", $result['message']);
    }  

    public function testAjouterRecurrenceFreqSupÃ©rieurA5Ans(): void {
        $timestamp = mktime(0,0,0,04,10,2025);
        $result = $this->modele->ajouterRecurrence(
            "Test Sujet Freq Invalide", "Description de test", date("Y/m/d",$timestamp),6,null,2,"annÃ©e",null
        );

        $this->assertFalse($result['success']);
        $this->assertEquals("Entrez une frÃ©quence valide pour les annÃ©es, pas plus de 5 ans", $result['message']);
    }  

    public function testAjouterRecurrenceSansUnitefrequence(): void {
        $timestamp = mktime(0,0,0,04,10,2025);
        $result = $this->modele->ajouterRecurrence(
            "TestSujet", "Description de test", date("Y/m/d",$timestamp),8,null,2,null,"jour"
        );

        $this->assertFalse($result['success']);
        $this->assertEquals("UnitÃ© de temps invalide.", $result['message']);
    }

    public function testAjouterRecurrenceSansTitre(): void {
        $timestamp = mktime(0,0,0,04,10,2025);
        $result = $this->modele->ajouterRecurrence(
            "", "Description de test", date("Y/m/d",$timestamp),8,null,2,"mois",null
        );

        $this->assertFalse($result['success']);
        $this->assertEquals("Entrez un titre pour la maintenance", $result['message']);
    }

    public function testAjouterRecurrenceSansfrequenceRappel(): void {
        $timestamp = mktime(0,0,0,04,10,2025);
        $result = $this->modele->ajouterRecurrence(
            "TestSujet", "Description de test", date("Y/m/d",$timestamp),8,null,2,"mois","jour"
        );

        $this->assertTrue($result['success']);
    }

    public function testAjouterRecurrenceFrequenceEndessousfrequenceRappel(): void {
        $timestamp = mktime(0,0,0,04,10,2025);
        $result = $this->modele->ajouterRecurrence(
            "TestSujet", "Description de test", date("Y/m/d",$timestamp),2,5,7,"jour","jour"
        );

        $this->assertFalse($result['success']);
        $this->assertEquals("Le dÃ©lai de rappel ne peut Ãªtre supÃ©rieur Ã  la frÃ©quence de la maintenance.", $result['message']);
    }

    public function testAjouterRecurrenceSansUniteRappelMaisAvecFrequence(): void {
        $timestamp = mktime(0,0,0,04,10,2025);
        $result = $this->modele->ajouterRecurrence(
            "TestSujet", "Description de test", date("Y/m/d",$timestamp),2,8,2,"mois",null
        );

        $this->assertFalse($result['success']);
        $this->assertEquals("Vous ne pouvez pas insÃ©rer une frÃ©quence de rappel si vous n'avez pas sÃ©lectionnÃ© une unitÃ© de rappel", $result['message']);
    }



    public function testModifierRecurrence(): void {
        $result = $this->modele->ajouterRecurrence(
            "Test Sujet_modif", "Description de test", "2025-04-04",8,null,2,"mois",null
        );

        $this->assertTrue($result['success']);

        $stmt = $this->pdo->query("SELECT id_recurrence FROM recurrence WHERE sujet_reccurrence = 'Test Sujet_modif'");
        $idRecurrence = $stmt->fetchColumn(); // On rÃ©cupÃ¨re l'ID

        $result = $this->modele->update($idRecurrence,"Test_sujet_modifie","Description de test modifiÃ©","2025-05-27",5,2,4,"annÃ©e","mois");
        $this->assertTrue($result['success']);
    }

    public function testSupprimerRecurrence(): void {
        $result = $this->modele->ajouterRecurrence(
            "Test Sujet supp", "Description de test", "2025-04-04",8,null,2,"mois",null
        );

        $this->assertTrue($result['success']);

        $stmt = $this->pdo->query("SELECT id_recurrence FROM recurrence WHERE sujet_reccurrence = 'Test Sujet supp'");
        $idRecurrence = $stmt->fetchColumn(); // On rÃ©cupÃ¨re l'ID

        $result = $this->modele->delete($idRecurrence);

        $this->assertTrue($result['success']);
    }

    public function testDatabaseUsed(): void {
        $stmt = $this->pdo->query("SELECT DATABASE()");
        $dbName = $stmt->fetchColumn();
        $this->assertEquals("albatros_test", $dbName);
    }

    public function testDatabasefalse(): void {
        $this->expectException(PDOException::class); 
        // Cette table n'existe pas, donc Ã§a dÃ©clenche bien une exception
        $this->pdo->query("SELECT * FROM table_qui_pas");
    }

    public function testInvalidDatabaseConnection(): void {
        $this->expectException(PDOException::class);
    
        new PDO("mysql:host=localhost;dbname=bd_invalide", "root", ""); // mauvaise base
    }



}
?>